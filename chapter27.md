# 27 插曲：线程API
本章简要介绍线程API的主要部分。每个部分将在随后的章节中进一步解释，为我们展示了如何使用API。更多细节可以在各种书籍和网上找到源[B89，B97，B +96，X +96]。我们应该注意到，后面的章节有很多例子介绍了锁和条件变量的概念比较慢；从而更好本章用作参考

> 关键：如何创建和控制线程
> 
> 操作系统应该为线程的创建和控制提供什么接口？应该如何设计这些接口来保证易用性以及效用？


## 27.1 线程创建
创建多线程程序第一步要完成的事当然是创建新的线程，所以必须有一些线程创建的接口，在POSIX中，它很简单：

```
#include <pthread.h>
int
pthread_create( pthread_t * thread,
       const pthread_attr_t * attr,
    void * (*start_routine)(void*),
                        void * arg);
```

这个定义虽然看起来有点复杂，但是其实并不是那么糟糕。它有4个参数分别是thread, attr, start_routine和arg。

第一个参数，```thread```，是指向类型为pthread_t结构体的指针；我们要使用这个结构体与这个线程交互，所以我们需要传入它用pthread_create初始化它。

第二个参数，```attr```，被用来表明该线程可能拥有的属性。比如说设置堆栈的大小或者表明该线程的调度优先级。属性被独立的```pthread_attr_init()```调用初始化；可以在手册中查看更详细的信息。然而，在大多数情况下，用默认值就够了，也就是传入一个```NULL```。

第三个参数是最复杂的，但是这正是问题所在：该线程创建后会运行什么函数呢？在C语言中，我们把它叫做函数指针，这个参数告诉我们它需要的是：一个函数名为start_route，拥有一个```void*```参数（正如start_route后面括号内的内容），同时返回一个```void*```型的值（比如void指针）。

如果该函数需要一个整形参数而不是```void```型指针，声明会像这个一样：
```
int pthread_create(..., // 前两个参数一样
                    void * (*start_routine)(int),
                    int arg);
```
如果需要一个```void```型指针的参数，但是返回一个整数，声明会像这个一样：
```
int pthread_create(..., // 前两个参数一样
                    void * (*start_routine)(int),
                    int arg);
```
最终，第四个参数```arg```正是会被传入该线程刚开始要执行的函数的参数。你也许会问：我们为什么需要这个```void```型指针？恩，答案非常简单：使用```void```型指针作为传入函数```start_routine```的一个参数允许我们传入任何类型的函数；同理可以允许该线程返回任何类型的结果。

让我们看一下图27.1的例子。在这里，我们只是创建一个线程并传递两个参数，打包成一个单一类型的，我们自己定义（myarg T）。线程，一旦创建，可以简单地解包转型成需要的参数。

就是这样！一旦你创建一个线程，你就真的拥有另一个运行上下文，使用自己的运行堆栈，与程序内所有存在的线程共享相同地址空间。好玩的事情要开始了！


## 27.2 线程完成

## 27.3 锁

## 27.4 条件变量

## 27.5 编译与运行

## 27.6 总结
